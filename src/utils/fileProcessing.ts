// utils/fileProcessing.ts - í—¤ë” ê°ì§€ ì•½í™” ë° ì›ë³¸ êµ¬ì¡° ì™„ì „ ë³´ì¡´ ë²„ì „
import * as XLSX from 'xlsx';

// ============================================================================
// ìƒíƒœ ê´€ë¦¬ ì¸í„°í˜ì´ìŠ¤ í™•ì¥ (ê¸°ì¡´ ì½”ë“œì™€ í˜¸í™˜ì„± ìœ ì§€)
// ============================================================================

// ê¸°ì¡´ SheetData ì¸í„°í˜ì´ìŠ¤ í™•ì¥
export interface ExtendedSheetData {
  sheetName: string;
  headers: string[]; // ê¸°ì¡´ í˜¸í™˜ì„± ìœ ì§€
  data: string[][]; // ê¸°ì¡´ í˜¸í™˜ì„± ìœ ì§€
  rawData: string[][]; // ì™„ì „í•œ ì›ë³¸ ë°ì´í„°
  
  // ìƒˆë¡œ ì¶”ê°€ëœ ìƒì„¸ ì •ë³´
  headerInfo: {
    headerRow: number; // ì‹¤ì œ í—¤ë”ê°€ ìœ„ì¹˜í•œ í–‰ (ì—†ìœ¼ë©´ -1)
    headerDetails: Array<{
      name: string;
      originalColumn: number;
      columnLetter: string;
    }>;
    headerPositions: { [originalCol: number]: number };
    isAutoGenerated?: boolean; // í—¤ë”ê°€ ìë™ ìƒì„±ë˜ì—ˆëŠ”ì§€ ì—¬ë¶€
  };
  
  dataBounds: {
    minRow: number;
    maxRow: number;
    minCol: number;
    maxCol: number;
    actualStartRow: number; // ì‹¤ì œ ë°ì´í„° ì‹œì‘ í–‰
    actualStartCol: number; // ì‹¤ì œ ë°ì´í„° ì‹œì‘ ì—´
  };
  
  metadata?: {
    rowCount: number;
    columnCount: number;
    headerRow: number;
    headerRowData?: string[];
    headerMap?: { [index: number]: number };
    dataRange: {
      startRow: number;
      endRow: number;
      startCol: number;
      endCol: number;
      startColLetter: string;
      endColLetter: string;
    };
    preserveOriginalStructure?: boolean;
    lastModified?: Date;
    // ìƒˆë¡œ ì¶”ê°€ëœ ì›ë³¸ êµ¬ì¡° ì •ë³´
    originalHeaderRow?: number;
    originalDataBounds?: {
      minRow: number;
      maxRow: number;
      minCol: number;
      maxCol: number;
      actualStartRow: number;
      actualStartCol: number;
    };
    headerDetails?: Array<{
      name: string;
      originalColumn: number;
      columnLetter: string;
    }>;
  };
}

// ============================================================================
// í•µì‹¬ ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë“¤
// ============================================================================

// ì²« ë²ˆì§¸ ë¹„ì–´ìˆì§€ ì•Šì€ ì…€ì„ ì°¾ëŠ” í•¨ìˆ˜
export const findFirstNonEmptyCell = (data: string[][]): { row: number; col: number } => {
  for (let row = 0; row < data.length; row++) {
    if (!data[row]) continue;
    for (let col = 0; col < data[row].length; col++) {
      if (data[row][col] && data[row][col].toString().trim() !== '') {
        return { row, col };
      }
    }
  }
  return { row: 0, col: 0 };
};

// í—¤ë” í–‰ì„ ì°¾ëŠ” í•¨ìˆ˜ - ì•½í™”ëœ ë²„ì „
export const findHeaderRow = (data: string[][], startRow: number = 0): number => {
  // ë¹ˆ ë°ì´í„°ì¸ ê²½ìš°
  if (!data || data.length === 0) {
    return -1;
  }

  let bestHeaderRow = -1;
  let bestScore = 0;
  
  // ì²˜ìŒ 10í–‰ ë‚´ì—ì„œë§Œ í—¤ë” ì°¾ê¸° ì‹œë„
  for (let row = startRow; row < Math.min(data.length, startRow + 10); row++) {
    if (!data[row]) continue;
    
    let nonEmptyCount = 0;
    let consecutiveNonEmpty = 0;
    let maxConsecutive = 0;
    
    for (let col = 0; col < data[row].length; col++) {
      const cellValue = data[row][col];
      const cellStr = cellValue ? cellValue.toString().trim() : '';
      
      if (cellStr !== '') {
        nonEmptyCount++;
        consecutiveNonEmpty++;
        maxConsecutive = Math.max(maxConsecutive, consecutiveNonEmpty);
      } else {
        consecutiveNonEmpty = 0;
      }
    }
    
    // ë§¤ìš° ê´€ëŒ€í•œ í—¤ë” ì ìˆ˜ ê³„ì‚° - ì—°ì†ëœ ì…€ì´ 2ê°œ ì´ìƒì´ë©´ í—¤ë” í›„ë³´
    const score = maxConsecutive;
    
    if (maxConsecutive >= 2 && score > bestScore) {
      bestScore = score;
      bestHeaderRow = row;
    }
  }
  
  // í—¤ë”ë¥¼ ì°¾ì§€ ëª»í•œ ê²½ìš° -1 ë°˜í™˜ (ì—ëŸ¬ê°€ ì•„ë‹˜)
  return bestHeaderRow;
};

// ì‹¤ì œ ë°ì´í„° ë²”ìœ„ë¥¼ ì°¾ëŠ” í•¨ìˆ˜
export const findActualDataBounds = (data: string[][]): {
  minRow: number;
  maxRow: number;
  minCol: number;
  maxCol: number;
} => {
  let minRow = data.length;
  let maxRow = -1;
  let minCol = Number.MAX_SAFE_INTEGER;
  let maxCol = -1;
  
  for (let row = 0; row < data.length; row++) {
    if (!data[row]) continue;
    
    let hasData = false;
    for (let col = 0; col < data[row].length; col++) {
      const cellValue = data[row][col];
      if (cellValue && cellValue.toString().trim() !== '') {
        hasData = true;
        minCol = Math.min(minCol, col);
        maxCol = Math.max(maxCol, col);
      }
    }
    
    if (hasData) {
      minRow = Math.min(minRow, row);
      maxRow = Math.max(maxRow, row);
    }
  }
  
  // ë°ì´í„°ê°€ ì—†ëŠ” ê²½ìš° ê¸°ë³¸ê°’ ë°˜í™˜
  if (maxRow === -1) {
    return { minRow: 0, maxRow: 0, minCol: 0, maxCol: 0 };
  }
  
  return { minRow, maxRow, minCol, maxCol };
};

// ìë™ìœ¼ë¡œ í—¤ë” ìƒì„±í•˜ëŠ” í•¨ìˆ˜
export const generateAutoHeaders = (colCount: number, startCol: number = 0): Array<{
  name: string;
  originalColumn: number;
  columnLetter: string;
}> => {
  const headers: Array<{
    name: string;
    originalColumn: number;
    columnLetter: string;
  }> = [];
  
  for (let i = 0; i < colCount; i++) {
    const colIndex = startCol + i;
    const colLetter = columnIndexToLetter(colIndex);
    headers.push({
      name: `Column ${colLetter}`,
      originalColumn: colIndex,
      columnLetter: colLetter
    });
  }
  
  return headers;
};

// í—¤ë” ì •ë³´ ì¶”ì¶œ - ì›ë³¸ ìœ„ì¹˜ ì •ë³´ í¬í•¨ (í—¤ë”ê°€ ì—†ì„ ê²½ìš° ìë™ ìƒì„±)
export const extractHeaderInfo = (
  data: string[][], 
  headerRowIndex: number,
  dataBounds: { minCol: number; maxCol: number }
): {
  headers: Array<{
    name: string;
    originalColumn: number;
    columnLetter: string;
  }>;
  headerPositions: { [originalCol: number]: number };
  isAutoGenerated: boolean;
} => {
  // í—¤ë”ê°€ ì—†ëŠ” ê²½ìš° ìë™ ìƒì„±
  if (headerRowIndex === -1 || !data[headerRowIndex]) {
    const colCount = dataBounds.maxCol - dataBounds.minCol + 1;
    const autoHeaders = generateAutoHeaders(colCount, dataBounds.minCol);
    
    const headerPositions: { [originalCol: number]: number } = {};
    autoHeaders.forEach((header, index) => {
      headerPositions[header.originalColumn] = index;
    });
    
    return {
      headers: autoHeaders,
      headerPositions,
      isAutoGenerated: true
    };
  }
  
  // ê¸°ì¡´ í—¤ë” ì¶”ì¶œ ë¡œì§
  const headers: Array<{
    name: string;
    originalColumn: number;
    columnLetter: string;
  }> = [];
  
  const headerPositions: { [originalCol: number]: number } = {};
  const headerRow = data[headerRowIndex];
  
  // ë°ì´í„° ë²”ìœ„ ë‚´ì˜ ëª¨ë“  ì—´ì— ëŒ€í•´ í—¤ë” ìƒì„±
  for (let col = dataBounds.minCol; col <= dataBounds.maxCol; col++) {
    const headerValue = headerRow[col];
    const headerStr = String(headerValue || '').trim();
    
    const headerIndex = headers.length;
    headerPositions[col] = headerIndex;
    
    // ë¹ˆ í—¤ë”ëŠ” ìë™ìœ¼ë¡œ ì´ë¦„ ìƒì„±
    const headerName = headerStr || `Column ${columnIndexToLetter(col)}`;
    
    headers.push({
      name: headerName,
      originalColumn: col,
      columnLetter: columnIndexToLetter(col)
    });
  }
  
  return { headers, headerPositions, isAutoGenerated: false };
};

// ì—´ ì¸ë±ìŠ¤ë¥¼ ì—‘ì…€ ì—´ ì´ë¦„ìœ¼ë¡œ ë³€í™˜
export const columnIndexToLetter = (index: number): string => {
  let result = '';
  while (index >= 0) {
    result = String.fromCharCode(65 + (index % 26)) + result;
    index = Math.floor(index / 26) - 1;
  }
  return result;
};

// ì—‘ì…€ ì—´ ì´ë¦„ì„ ì¸ë±ìŠ¤ë¡œ ë³€í™˜
export const columnLetterToIndex = (letter: string): number => {
  let result = 0;
  for (let i = 0; i < letter.length; i++) {
    result = result * 26 + (letter.charCodeAt(i) - 64);
  }
  return result - 1;
};

// ============================================================================
// íŒŒì¼ ì²˜ë¦¬ ë©”ì¸ í•¨ìˆ˜ë“¤
// ============================================================================

// XLSX íŒŒì¼ ì²˜ë¦¬ í•¨ìˆ˜ - í—¤ë” ê°ì§€ ì•½í™” ë° ì›ë³¸ êµ¬ì¡° ì™„ì „ ë³´ì¡´ ë²„ì „
export const processXLSXFile = async (file: File): Promise<{
  sheets: Array<ExtendedSheetData>;
  fileName: string;
}> => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    
    reader.onload = (e) => {
      try {
        const data = new Uint8Array(e.target?.result as ArrayBuffer);
        const workbook = XLSX.read(data, { 
          type: 'array',
          cellFormula: true, // ìˆ˜ì‹ ë³´ì¡´
          cellStyles: true,  // ìŠ¤íƒ€ì¼ ë³´ì¡´
          cellDates: true,   // ë‚ ì§œ ë³´ì¡´
          sheetStubs: true,  // ë¹ˆ ì…€ë„ í¬í•¨
          raw: false         // í¬ë§·ëœ ê°’ ì‚¬ìš©
        });
        
        const processedSheets: ExtendedSheetData[] = workbook.SheetNames.map(sheetName => {
          console.log(`Processing sheet: ${sheetName}`);
          const worksheet = workbook.Sheets[sheetName];
          
          // ì›Œí¬ì‹œíŠ¸ì˜ ë²”ìœ„ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
          const range = XLSX.utils.decode_range(worksheet['!ref'] || 'A1');
          
          // ì›ë³¸ ë°ì´í„° ì¶”ì¶œ - ì™„ì „í•œ ì›ë³¸ êµ¬ì¡° ìœ ì§€
          const rawData = XLSX.utils.sheet_to_json(worksheet, { 
            header: 1,
            defval: '', // ë¹ˆ ì…€ì„ ë¹ˆ ë¬¸ìì—´ë¡œ ì²˜ë¦¬
            raw: false, // í¬ë§·ëœ ê°’ ì‚¬ìš©
            blankrows: true, // ë¹ˆ í–‰ ìœ ì§€
            range: worksheet['!ref'] // ì „ì²´ ë²”ìœ„ ì‚¬ìš©
          }) as string[][];
          
          console.log(`Raw data dimensions for ${sheetName}: ${rawData.length} rows, range: ${worksheet['!ref']}`);
          
          // ì™„ì „íˆ ë¹ˆ ì‹œíŠ¸ ì²˜ë¦¬
          const hasAnyData = rawData.some(row => 
            row && row.some(cell => cell && cell.toString().trim() !== '')
          );
          
          if (!hasAnyData) {
            console.log(`Sheet ${sheetName} is completely empty`);
            return {
              sheetName,
              rawData: [[]],
              headers: [],
              data: [],
              headerInfo: {
                headerRow: -1,
                headerDetails: [],
                headerPositions: {},
                isAutoGenerated: true
              },
              dataBounds: {
                minRow: 0, maxRow: 0, minCol: 0, maxCol: 0,
                actualStartRow: 0, actualStartCol: 0
              },
              metadata: {
                headerRow: -1,
                rowCount: 0,
                columnCount: 0,
                dataRange: {
                  startRow: 0, endRow: 0, startCol: 0, endCol: 0,
                  startColLetter: 'A', endColLetter: 'A'
                },
                preserveOriginalStructure: true,
                lastModified: new Date()
              }
            };
          }
          
          // ì‹¤ì œ ë°ì´í„° ë²”ìœ„ ì°¾ê¸°
          const dataBounds = findActualDataBounds(rawData);
          console.log(`Data bounds for ${sheetName}:`, dataBounds);
          
          // í—¤ë” í–‰ ì°¾ê¸° (ëª» ì°¾ì•„ë„ OK)
          const headerRowIndex = findHeaderRow(rawData, dataBounds.minRow);
          console.log(`Header row for ${sheetName}: ${headerRowIndex} (${headerRowIndex === -1 ? 'not found, will auto-generate' : 'found'})`);
          
          // í—¤ë” ì •ë³´ ì¶”ì¶œ (ì—†ìœ¼ë©´ ìë™ ìƒì„±)
          const { headers: headerDetails, headerPositions, isAutoGenerated } = 
            extractHeaderInfo(rawData, headerRowIndex, dataBounds);
          
          console.log(`Headers for ${sheetName} (${isAutoGenerated ? 'auto-generated' : 'detected'}):`, 
            headerDetails.map(h => `${h.name}(${h.columnLetter})`));
          
          // ê¸°ì¡´ í˜¸í™˜ì„±ì„ ìœ„í•œ ë‹¨ìˆœí•œ ë°°ì—´ ìƒì„±
          const simpleHeaders = headerDetails.map(h => h.name);
          
          // ë°ì´í„° ì‹œì‘ í–‰ ê²°ì •
          const dataStartRow = headerRowIndex === -1 
            ? dataBounds.minRow // í—¤ë”ê°€ ì—†ìœ¼ë©´ ì²« ë°ì´í„° í–‰ë¶€í„°
            : Math.max(headerRowIndex + 1, dataBounds.minRow); // í—¤ë” ë‹¤ìŒ í–‰ë¶€í„°
          
          // ê¸°ì¡´ í˜¸í™˜ì„±ì„ ìœ„í•œ ë°ì´í„° ë°°ì—´ ìƒì„±
          const processedData: string[][] = [];
          
          for (let row = dataStartRow; row <= dataBounds.maxRow; row++) {
            if (!rawData[row]) continue;
            
            const dataRow: string[] = [];
            headerDetails.forEach(headerInfo => {
              const cellValue = rawData[row][headerInfo.originalColumn] || '';
              dataRow.push(String(cellValue));
            });
            
            // ëª¨ë“  í–‰ì„ ì¶”ê°€ (ë¹ˆ í–‰ë„ í¬í•¨í•˜ì—¬ ì›ë³¸ êµ¬ì¡° ìœ ì§€)
            processedData.push(dataRow);
          }
          
          console.log(`Processed ${processedData.length} data rows for ${sheetName}`);
          
          const result: ExtendedSheetData = {
            sheetName,
            rawData, // ì™„ì „í•œ ì›ë³¸ ë³´ì¡´
            headers: simpleHeaders, // ê¸°ì¡´ í˜¸í™˜ì„±
            data: processedData, // ê¸°ì¡´ í˜¸í™˜ì„±
            headerInfo: {
              headerRow: headerRowIndex,
              headerDetails,
              headerPositions,
              isAutoGenerated
            },
            dataBounds: {
              ...dataBounds,
              actualStartRow: dataStartRow,
              actualStartCol: dataBounds.minCol
            },
            metadata: {
              headerRow: headerRowIndex,
              headerRowData: headerRowIndex !== -1 ? rawData[headerRowIndex] : undefined,
              headerMap: headerPositions,
              rowCount: processedData.length,
              columnCount: simpleHeaders.length,
              dataRange: {
                startRow: dataStartRow,
                endRow: dataBounds.maxRow,
                startCol: dataBounds.minCol,
                endCol: dataBounds.maxCol,
                startColLetter: columnIndexToLetter(dataBounds.minCol),
                endColLetter: columnIndexToLetter(dataBounds.maxCol)
              },
              preserveOriginalStructure: true,
              lastModified: new Date(),
              // ìƒˆë¡œ ì¶”ê°€ëœ ì›ë³¸ êµ¬ì¡° ì •ë³´
              originalHeaderRow: headerRowIndex,
              originalDataBounds: {
                ...dataBounds,
                actualStartRow: dataStartRow,
                actualStartCol: dataBounds.minCol
              },
              headerDetails
            }
          };
          
          return result;
        });
        
        // ì™„ì „íˆ ë¹ˆ ì‹œíŠ¸ë¥¼ ì œì™¸í•˜ê³  ë°˜í™˜
        const nonEmptySheets = processedSheets.filter(sheet => 
          sheet.rawData.length > 1 || // ì—¬ëŸ¬ í–‰ì´ ìˆê±°ë‚˜
          (sheet.rawData.length === 1 && sheet.rawData[0].length > 0 && sheet.rawData[0].some(cell => cell !== '')) // ë°ì´í„°ê°€ ìˆëŠ” ê²½ìš°
        );
        
        console.log(`Successfully processed ${nonEmptySheets.length} non-empty sheets from ${file.name}`);
        
        resolve({
          sheets: nonEmptySheets.length > 0 ? nonEmptySheets : processedSheets, // ëª¨ë“  ì‹œíŠ¸ê°€ ë¹„ì–´ìˆì–´ë„ ìµœì†Œ 1ê°œëŠ” ë°˜í™˜
          fileName: file.name
        });
      } catch (error) {
        console.error('XLSX íŒŒì¼ ì²˜ë¦¬ ì˜¤ë¥˜:', error);
        reject(error);
      }
    };
    
    reader.onerror = () => reject(new Error('íŒŒì¼ ì½ê¸° ì‹¤íŒ¨'));
    reader.readAsArrayBuffer(file);
  });
};

// ë””ë²„ê¹…ì„ ìœ„í•œ ì‹œíŠ¸ ì •ë³´ ì¶œë ¥
export const debugSheetInfo = (sheetData: ExtendedSheetData): void => {
  console.group(`ğŸ“Š Sheet Debug Info: ${sheetData.sheetName}`);
  console.log('ğŸ“ Raw Data Dimensions:', `${sheetData.rawData.length} rows Ã— ${sheetData.rawData[0]?.length || 0} cols`);
  console.log('ğŸ“ Header Row:', sheetData.headerInfo.headerRow, sheetData.headerInfo.isAutoGenerated ? '(auto-generated)' : '(detected)');
  console.log('ğŸ·ï¸ Headers:', sheetData.headerInfo.headerDetails.map(h => `${h.name}(${h.columnLetter})`));
  console.log('ğŸ“Š Data Bounds:', sheetData.dataBounds);
  console.log('ğŸ“‹ Processed Data:', `${sheetData.data.length} rows Ã— ${sheetData.headers.length} cols`);
  
  // ìƒ˜í”Œ ë°ì´í„° ì¶œë ¥ (ì²˜ìŒ 3í–‰)
  if (sheetData.data.length > 0) {
    console.log('ğŸ“ Sample Data:');
    console.table(sheetData.data.slice(0, 3));
  }
  
  console.groupEnd();
};

// ë‚˜ë¨¸ì§€ í•¨ìˆ˜ë“¤ì€ ê·¸ëŒ€ë¡œ ìœ ì§€...
export const findDataRange = (rawData: string[][], headerRow: number) => {
  const headerRowData = rawData[headerRow] || [];
  const dataBounds = findActualDataBounds(rawData);
  
  // í—¤ë”ê°€ ì—†ëŠ” ê²½ìš°ë¥¼ ìœ„í•œ ì²˜ë¦¬
  if (headerRow === -1) {
    const { headers, headerPositions } = extractHeaderInfo(rawData, -1, dataBounds);
    
    return {
      headerRowData: headers.map(h => h.name),
      validHeaders: headers.map(h => h.name),
      headerMap: headerPositions,
      maxRow: dataBounds.maxRow,
      maxCol: dataBounds.maxCol
    };
  }
  
  // ê¸°ì¡´ ë¡œì§
  const validHeaders: string[] = [];
  const headerMap: { [key: number]: number } = {};
  
  headerRowData.forEach((header, index) => {
    if (header && String(header).trim() !== '') {
      headerMap[index] = validHeaders.length;
      validHeaders.push(String(header).trim());
    }
  });
  
  return {
    headerRowData,
    validHeaders,
    headerMap,
    maxRow: dataBounds.maxRow,
    maxCol: dataBounds.maxCol
  };
};